.data
STRINGTABLE:
	.byt "aeiouy",228,246,229,233,"AEIOUY",196,214,197,201,"0123456",0,"aeiouy",228
	.byt 246,229,233,"AEIOUY",196,214,197,201,0,"flmnrswxFLMNRSWX479",0,"aouAOU023"
	.byt "68",0,228,246,"y",196,214,"Y14579",0,"0123456789",0,"01234568",0,"hkq"
	.byt 229,"HKQ",197,0,"20teese",0,"ei",233,"EI",201,0,"nNeEnN",0,"00'hu",0,"10k"
	.byt "se",0,"20tee",0,"_kKkK",0,"_pPpP",0,"_tTtT",0,"iIkK-",0,"00't",0,"00:a",0
	.byt "00:t",0,"00:",228,0,"00tt",0,"0ksi",0,"0lle",0,"30se",0,"30st",0,"aA",228
	.byt 196,0,"eEdD",0,"uUtT",0,"wWoO",0,"yYtT",0,"00'",0,"00:",0,"00i",0,"00t",0
	.byt "10e",0,"1ll",0,"1lt",0,"1ss",0,"1st",0,"1tt",0,"20e",0,"sS,",0,"00",0,"0"
	.byt "n",0,"11",0,"1n",0,"21",0,"a",228,0,"zZ",0
	; Func Clobbered : 3f
.text
DoSuff:
	; 1 outgoing mem params
	; 4 incoming params, 1 of which are mem params
	; 3 local mem vars, 1 of which are reused params, leaving only 2 true local vars
	; As a consequence, stack will have 3 local slots (true vars + outgoing mem params + align).
	; An offset of 4 items (8 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)
	; True local variables               reside at stack indexes 1..2 (bytes 2..5)
	; Incoming memory params             reside at stack indexes 4..4 (bytes 8..9)
	; Local variables reused from params reside at stack indexes 4..4 (bytes 8..9)


	phx
	phx
	phx
.(
__entry:
	; fcall	 R2 R2 R1 0 0 R0
	sta 5,s
	txa
	tsx
	sty 3,x
	tyx
	sta 1,s
	tdc
	tay
	per (+)-1
	pha
	pha
	lda 6+5,s
	sec
	sbc #1
	sta 3,s
	pla
	rts
	+
	tsx
	ldy 3,x
	; add	 R0 R3 1
	phy
	tsx
	txy
	ldx 11,y
	inx
	ply
	; fcall	 R0 "stpcpy" R2 R0
	phy
	txy
	tax
	jsr stpcpy
	tax
	ply
	; read	 R2 R3
	phy
	ldy #0
	lda (11,s),y
	and #$FF
	ply
	; ifeq	 R2 48, JMP L20
	cmp #48
	beq L20
	; fcall	 R1 "a" R1
	phx
	tyx
	jsr a
	tay
	plx
L51:
	; fcall	 R2 "append" R0 R1
	jsr append
L3:
	; ret	 R2
	bra __exit
L20:
	; ret	 R0
	txa
	bra __exit
__exit:
.)
	plx
	plx
	plx

	rts
	; Func Clobbered : 7
.text
Do_A:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "PartitiveStem" "STRINGTABLE"+311
	lda #STRINGTABLE+311
	sta 1,s
	lda #PartitiveStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_HUN:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "IllativeStem" "STRINGTABLE"+307
	lda #STRINGTABLE+307
	sta 1,s
	lda #IllativeStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_KSI:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+211
	lda #STRINGTABLE+211
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_LLA:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+276
	lda #STRINGTABLE+276
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_LLE:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+216
	lda #STRINGTABLE+216
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_LTA:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+280
	lda #STRINGTABLE+280
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_N:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+307
	lda #STRINGTABLE+307
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_NA:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "EssiveStem" "STRINGTABLE"+313
	lda #STRINGTABLE+313
	sta 1,s
	lda #EssiveStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_SSA:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+284
	lda #STRINGTABLE+284
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_STA:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+288
	lda #STRINGTABLE+288
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Do_TTA:
	; 1 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "DoSuff" R0 R1 "SoftStem" "STRINGTABLE"+292
	lda #STRINGTABLE+292
	sta 1,s
	lda #SoftStem
	jsr DoSuff
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 1f
.text
EndPattern:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 2 local mem vars, 0 of which are reused params, leaving only 2 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..1 (bytes 0..3)


	phx
	phx
.(
__entry:
	; fcall	 R2 "strend" R0
	phx
	phy
	jsr strend
	ply
	plx
L18:
	; ifnz	 R1, JMP L16
	cpy #1 
	bcs L16
L1:
	; ret	 R1
	tya
	bra __exit
L16:
	; read	 R3 R1
	pha
	lda !0,y
	and #$FF
	sta 3,s
	pla
	; ifnz	 R3, JMP L17
	pha
	lda 3,s
	cmp #1 
	pla
	bcs L17
	; JMP L1
	bra L1
L17:
	; ifeq	 R0 R2, JMP L5
	sta 1,s
	txa
	eor 1,s
	cmp #1 
	lda 1,s
	bcc L5
	; add	 R3 R2 -1
	pha
	clc
	adc #-1
	sta 3,s
	pla
	; read	 R4 R3
	phy
	pha
	ldy #0
	lda (5,s),y
	and #$FF
	sta 7,s
	pla
	ply
	; copy	 R2 R3
	lda 1,s
	; fcall	 R1 "Judge" R4 R1
	phx
	pha
	lda 7,s
	tax
	jsr Judge
	tay
	pla
	plx
	; JMP L18
	bra L18
L5:
	; ret	 0
	tdc
	bra __exit
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : f
.text
EssiveStem:
	; 2 outgoing mem params
	; 4 incoming params, 1 of which are mem params
	; 1 local mem vars, 1 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..1 (bytes 0..3)
	; Incoming memory params             reside at stack indexes 3..3 (bytes 6..7)
	; Local variables reused from params reside at stack indexes 3..3 (bytes 6..7)


	phx
	phx
.(
__entry:
	; fcall	 R2 "SoftAndEssive" R0 1 1 R3 1
	lda 7,s
	sta 1,s
	lda #1
	tay
	sta 3,s
	jsr SoftAndEssive
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : f
.text
IllativeStem:
	; 2 outgoing mem params
	; 4 incoming params, 1 of which are mem params
	; 1 local mem vars, 1 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..1 (bytes 0..3)
	; Incoming memory params             reside at stack indexes 3..3 (bytes 6..7)
	; Local variables reused from params reside at stack indexes 3..3 (bytes 6..7)


	phx
	phx
.(
__entry:
	; fcall	 R1 "IsAlien" R0
	phx
	jsr IsAlien
	tay
	plx
	; ifnz	 R1, JMP L46
	cpy #1 
	bcs L46
	; fcall	 R1 "IsAbbrev" R0
	phx
	jsr IsAbbrev
	tay
	plx
	; ifnz	 R1, JMP L47
	cpy #1 
	bcs L47
	; fcall	 R1 "IsDe" R0
	phx
	jsr IsDe
	tay
	plx
	; ifnz	 R1, JMP L48
	cpy #1 
	bcs L48
	; fcall	 R1 "IsKKV" R0
	phx
	jsr IsKKV
	tay
	plx
	; ifnz	 R1, JMP L50
	cpy #1 
	bcs L50
	; fcall	 R2 "SoftAndEssive" R0 0 0 R3 0
	lda 7,s
	sta 1,s
	tdc
	tay
	sta 3,s
	jsr SoftAndEssive
L49:
	; add	 R0 R2 -1
	tax
	dex
	; read	 R1 R0
	pha
	lda !0,x
	and #$FF
	tay
	pla
	; fcall	 R2 "append" R2 R1
	tax
	jsr append
L3:
	; ret	 R2
	bra __exit
L50:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+310
	txy
	lda 7,s
	tax
	lda #STRINGTABLE+310
	jsr Outcome
	; JMP L49
	bra L49
L48:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+122
	txy
	lda 7,s
	tax
	lda #STRINGTABLE+122
	jsr Outcome
	; JMP L49
	bra L49
L47:
	; fcall	 R1 "a" R0
	phx
	jsr a
	tay
	plx
	; fcall	 R0 "Outcome" R3 R0 "STRINGTABLE"+260
	phy
	txy
	lda 9,s
	tax
	lda #STRINGTABLE+260
	jsr Outcome
	tax
	ply
	; fcall	 R2 "append" R0 R1
	jsr append
	; JMP L49
	bra L49
L46:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+144
	txy
	lda 7,s
	tax
	lda #STRINGTABLE+144
	jsr Outcome
	; JMP L3
	bra L3
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : 1f
.text
IsAbbrev:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 2 local mem vars, 0 of which are reused params, leaving only 2 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..1 (bytes 0..3)


	phx
	phx
.(
__entry:
	; fcall	 R3 "Length" R0
	phx
	jsr Length
	sta 3,s
	plx
	; ifeq	 R3 1, JMP L7
	lda 1,s
	cmp #1
	beq L7
L10:
	; ifnz	 R3, JMP L9
	lda 1,s
	bne L9
L7:
	; ret	 1
	lda #1
	bra __exit
L9:
	; add	 R2 R3 -1
	lda 1,s
	clc
	adc #-1
	; add	 R1 R0 R2
	sta 3,s
	txa
	clc
	adc 3,s
	tay
	lda 3,s
	; copy	 R3 R2
	sta 1,s
	; read	 R1 R1
	lda !0,y
	and #$FF
	tay
	; fcall	 R2 "IsNumber" R1
	phx
	tyx
	phx
	jsr IsNumber
	ply
	plx
	; ifnz	 R2, JMP L7
	cmp #1 
	bcs L7
	; fcall	 R1 "IsVowel" R1
	phx
	tyx
	jsr IsVowel
	tay
	plx
	; ifnz	 R1, JMP L5
	cpy #1 
	bcs L5
	; JMP L10
	bra L10
L5:
	; ret	 0
	tdc
	bra __exit
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : 7
.text
IsAki:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+180
	ldy #STRINGTABLE+180
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsAlien:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+246
	ldy #STRINGTABLE+246
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsDe:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+236
	ldy #STRINGTABLE+236
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsEs:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+300
	ldy #STRINGTABLE+300
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : f
.text
IsFront:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 1 local mem vars, 0 of which are reused params, leaving only 1 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R3 "strend" R0
	phx
	jsr strend
	sta 3,s
	plx
L6:
	; ifeq	 R0 R3, JMP L4
	txa
	cmp 1,s
	beq L4
	; add	 R1 R3 -1
	lda 1,s
	tay
	dey
	; read	 R2 R1
	lda !0,y
	and #$FF
	; copy	 R3 R1
	phx
	tsx
	sty 3,x
	plx
	; fcall	 R1 "find" R2 "STRINGTABLE"+69
	phx
	tax
	ldy #STRINGTABLE+69
	phx
	jsr find
	tay
	pla
	plx
	; ifnz	 R1, JMP L5
	cpy #1 
	bcs L5
	; fcall	 R1 "find" R2 "STRINGTABLE"+81
	phx
	tax
	ldy #STRINGTABLE+81
	jsr find
	tay
	plx
	; ifnz	 R1, JMP L7
	cpy #1 
	bcs L7
	; JMP L6
	bra L6
L7:
	; ret	 1
	lda #1
	bra __exit
L5:
	; ret	 0
	tdc
	bra __exit
L4:
	; read	 R0 R3
	ldy #0
	lda (1,s),y
	and #$FF
	tax
	; ifnz	 R0, JMP L8
	cpx #1 
	bcs L8
	; add	 R0 R3 -1
	tsx
	txy
	ldx 1,y
	dex
	; read	 R0 R0
	lda !0,x
	and #$FF
	tax
	; fcall	 R0 "find" R0 "STRINGTABLE"+113
	ldy #STRINGTABLE+113
	jsr find
	tax
	; eq	 R2 R0 0
	cpx #1
	lda #0
	rol
	eor #1
L3:
	; ret	 R2
	bra __exit
L8:
	; fcall	 R0 "find" R0 "STRINGTABLE"+130
	ldy #STRINGTABLE+130
	jsr find
	tax
	; ifnz	 R0, JMP L7
	cpx #1 
	bcs L7
	; add	 R3 R3 1
	tsx
	inc 1,x
	; JMP L4
	bra L4
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
IsKKV:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+162
	ldy #STRINGTABLE+162
	phx
	jsr EndPattern
	plx
	; ifnz	 R2, JMP L3
	cmp #1 
	bcs L3
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+168
	ldy #STRINGTABLE+168
	phx
	jsr EndPattern
	plx
	; ifnz	 R2, JMP L3
	cmp #1 
	bcs L3
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+174
	ldy #STRINGTABLE+174
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsNen:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+137
	ldy #STRINGTABLE+137
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsNumber:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "find" R0 "STRINGTABLE"+93
	ldy #STRINGTABLE+93
	jsr find
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsTu:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+241
	ldy #STRINGTABLE+241
	phx
	jsr EndPattern
	plx
	; ifnz	 R2, JMP L3
	cmp #1 
	bcs L3
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+251
	ldy #STRINGTABLE+251
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsV:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "EndPattern" R0 "STRINGTABLE"+302
	ldy #STRINGTABLE+302
	jsr EndPattern
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsVowel:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "find" R0 "STRINGTABLE"+28
	ldy #STRINGTABLE+28
	jsr find
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : 7
.text
IsVowelTypeChar:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R2 "find" R0 "STRINGTABLE"
	ldy #STRINGTABLE
	jsr find
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : f
.text
Judge:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 1 local mem vars, 0 of which are reused params, leaving only 1 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; read	 R3 R1
	lda !0,y
	and #$FF
	sta 1,s
	; fcall	 R2 "Judge1" R0 R3
	phx
	phy
	lda 5,s
	tay
	jsr Judge1
	ply
	plx
	; ifnz	 R2, JMP L14
	cmp #1 
	bcs L14
	; ifeq	 R0 R3, JMP L15
	txa
	cmp 1,s
	beq L15
	; add	 R1 R1 1
	iny
	; read	 R2 R1
	lda !0,y
	and #$FF
	; ifeq	 R0 R2, JMP L15
	sta 1,s
	txa
	cmp 1,s
	beq L15
L5:
	; ret	 0
	tdc
	bra __exit
L15:
	; add	 R2 R1 2
	tya
	clc
	adc #2
L3:
	; ret	 R2
	bra __exit
L14:
	; add	 R2 R1 1
	iny
	tya
	; JMP L3
	bra L3
__exit:
.)
	plx

	rts
	; Func Clobbered : 7
.text
Judge1:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; ifeq	 R1 44, JMP L11
	cpy #44
	beq L11
	; ifeq	 R1 95, JMP L12
	cpy #95
	beq L12
	; ifeq	 R1 45, JMP L13
	cpy #45
	beq L13
L5:
	; ret	 0
	tdc
	bra __exit
L13:
	; fcall	 R2 "find" R0 "STRINGTABLE"+231
	ldy #STRINGTABLE+231
	jsr find
L3:
	; ret	 R2
	bra __exit
L12:
	; fcall	 R2 "IsVowel" R0
	jsr IsVowel
	; JMP L3
	bra L3
L11:
	; fcall	 R2 "IsVowelTypeChar" R0
	jsr IsVowelTypeChar
	; JMP L3
	bra L3
__exit:
.)
	rts
	; Func Clobbered : f
.text
LastCharN:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 1 local mem vars, 0 of which are reused params, leaving only 1 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R2 "strend" R0
	phy
	jsr strend
	ply
	; neg	 R0 R1
	pha
	tya
	eor #-1
	tax
	inx
	pla
	; add	 R0 R0 R2
	sta 1,s
	txa
	clc
	adc 1,s
	tax
L45:
	; read	 R2 R0
	lda !0,x
	and #$FF
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : f
.text
Length:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 1 local mem vars, 0 of which are reused params, leaving only 1 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; fcall	 R1 "strend" R0
	phx
	jsr strend
	tay
	plx
	; neg	 R2 R0
	txa
	eor #-1
	sec
	adc #0
	; add	 R2 R1 R2
	sta 1,s
	tya
	clc
	adc 1,s
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : 1f
.text
Outcome:
	; 0 outgoing mem params
	; 3 incoming params, 0 of which are mem params
	; 2 local mem vars, 0 of which are reused params, leaving only 2 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..1 (bytes 0..3)


	phx
	phx
.(
__entry:
	; read	 R3 R2
	phx
	tax
	lda !0,x
	and #$FF
	sta 3,s
	txa
	plx
	; add	 R4 R3 -48
	pha
	lda 3,s
	clc
	adc #-48
	sta 5,s
	pla
	; add	 R3 R2 1
	pha
	clc
	adc #1
	sta 3,s
	pla
	; read	 R3 R3
	phy
	pha
	ldy #0
	lda (5,s),y
	and #$FF
	sta 5,s
	pla
	ply
	; add	 R3 R3 -48
	pha
	lda 3,s
	clc
	adc #-48
	sta 3,s
	pla
	; fcall	 R0 "stpcpyn" R0 R1 R4
	phy
	pha
	lda 7,s
	jsr stpcpyn
	tax
	pla
	ply
	; ifnz	 R3, JMP L24
	pha
	lda 3,s
	cmp #1 
	pla
	bcs L24
	; add	 R1 R2 2
	clc
	adc #2
	tay
	; fcall	 R2 "stpcpy" R0 R1
	jsr stpcpy
L3:
	; ret	 R2
	bra __exit
L24:
	; fcall	 R1 "LastCharN" R1 R3
	phx
	tyx
	lda 3,s
	tay
	jsr LastCharN
	tay
	plx
L51:
	; fcall	 R2 "append" R0 R1
	jsr append
	; JMP L3
	bra L3
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : f
.text
PartitiveStem:
	; 0 outgoing mem params
	; 4 incoming params, 1 of which are mem params
	; 1 local mem vars, 1 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame
	; Incoming memory params             reside at stack indexes 1..1 (bytes 2..3)
	; Local variables reused from params reside at stack indexes 1..1 (bytes 2..3)

.(
__entry:
	; fcall	 R2 "LastCharN" R0 1
	ldy #1
	phx
	jsr LastCharN
	plx
	; fcall	 R1 "IsAlien" R0
	phx
	pha
	jsr IsAlien
	tay
	pla
	plx
	; ifnz	 R1, JMP L34
	cpy #1 
	bcs L34
	; fcall	 R1 "IsAbbrev" R0
	phx
	pha
	jsr IsAbbrev
	tay
	pla
	plx
	; ifnz	 R1, JMP L35
	cpy #1 
	bcs L35
	; fcall	 R1 "IsEs" R0
	phx
	jsr IsEs
	tay
	plx
	; ifnz	 R1, JMP L38
	cpy #1 
	bcs L38
	; fcall	 R1 "IsDe" R0
	phx
	jsr IsDe
	tay
	plx
	; ifnz	 R1, JMP L39
	cpy #1 
	bcs L39
	; fcall	 R1 "IsNen" R0
	phx
	jsr IsNen
	tay
	plx
	; ifnz	 R1, JMP L40
	cpy #1 
	bcs L40
	; fcall	 R1 "IsAki" R0
	phx
	jsr IsAki
	tay
	plx
	; ifnz	 R1, JMP L42
	cpy #1 
	bcs L42
L41:
	; fcall	 R1 "IsV" R0
	phx
	jsr IsV
	tay
	plx
	; ifnz	 R1, JMP L33
	cpy #1 
	bcs L33
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+264
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+264
	jsr Outcome
L3:
	; ret	 R2
	bra __exit
L33:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+304
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+304
	jsr Outcome
	; JMP L3
	bra L3
L42:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+272
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+272
	jsr Outcome
	; JMP L3
	bra L3
L40:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+226
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+226
	jsr Outcome
	; JMP L3
	bra L3
L39:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+206
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+206
	jsr Outcome
	; JMP L3
	bra L3
L38:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+268
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+268
	jsr Outcome
	; JMP L3
	bra L3
L35:
	; fcall	 R1 "find" R2 "STRINGTABLE"+49
	phx
	tax
	ldy #STRINGTABLE+49
	phx
	jsr find
	tay
	pla
	plx
	; ifnz	 R1, JMP L36
	cpy #1 
	bcs L36
	; fcall	 R1 "find" R2 "STRINGTABLE"+322
	phx
	tax
	ldy #STRINGTABLE+322
	phx
	jsr find
	tay
	pla
	plx
	; ifnz	 R1, JMP L37
	cpy #1 
	bcs L37
	; fcall	 R1 "find" R2 "STRINGTABLE"+104
	phx
	tax
	ldy #STRINGTABLE+104
	jsr find
	tay
	plx
	; ifnz	 R1, JMP L26
	cpy #1 
	bcs L26
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+196
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+196
	jsr Outcome
	; JMP L3
	bra L3
L26:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+260
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+260
	jsr Outcome
	; JMP L3
	bra L3
L37:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+191
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+191
	jsr Outcome
	; JMP L3
	bra L3
L36:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+201
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+201
	jsr Outcome
	; JMP L3
	bra L3
L34:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+186
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+186
	jsr Outcome
	; JMP L3
	bra L3
__exit:
.)
	rts
	; Func Clobbered : 1f
.text
SoftAndEssive:
	; 0 outgoing mem params
	; 5 incoming params, 2 of which are mem params
	; 2 local mem vars, 2 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame
	; Incoming memory params             reside at stack indexes 1..2 (bytes 2..5)
	; Local variables reused from params reside at stack indexes 1..2 (bytes 2..5)

.(
__entry:
	; fcall	 R1 "IsAlien" R0
	phx
	jsr IsAlien
	tay
	plx
	; ifnz	 R1, JMP L25
	cpy #1 
	bcs L25
	; fcall	 R1 "IsAbbrev" R0
	phx
	jsr IsAbbrev
	tay
	plx
	; ifnz	 R1, JMP L26
	cpy #1 
	bcs L26
	; fcall	 R1 "IsEs" R0
	phx
	jsr IsEs
	tay
	plx
	; ifnz	 R1, JMP L27
	cpy #1 
	bcs L27
	; fcall	 R1 "IsDe" R0
	phx
	jsr IsDe
	tay
	plx
	; ifnz	 R1, JMP L28
	cpy #1 
	bcs L28
	; fcall	 R1 "IsNen" R0
	phx
	jsr IsNen
	tay
	plx
	; ifnz	 R1, JMP L29
	cpy #1 
	bcs L29
	; ifnz	 R4, JMP L30
	lda 5,s
	bne L30
	; fcall	 R1 "IsKKV" R0
	phx
	jsr IsKKV
	tay
	plx
	; ifnz	 R1, JMP L31
	cpy #1 
	bcs L31
L30:
	; fcall	 R1 "IsAki" R0
	phx
	jsr IsAki
	tay
	plx
	; ifnz	 R1, JMP L32
	cpy #1 
	bcs L32
L41:
	; fcall	 R1 "IsV" R0
	phx
	jsr IsV
	tay
	plx
	; ifnz	 R1, JMP L33
	cpy #1 
	bcs L33
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+264
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+264
	jsr Outcome
L3:
	; ret	 R2
	bra __exit
L33:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+304
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+304
	jsr Outcome
	; JMP L3
	bra L3
L32:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+296
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+296
	jsr Outcome
	; JMP L3
	bra L3
L31:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+316
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+316
	jsr Outcome
	; JMP L3
	bra L3
L29:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+221
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+221
	jsr Outcome
	; JMP L3
	bra L3
L28:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+156
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+156
	jsr Outcome
	; JMP L3
	bra L3
L27:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+150
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+150
	jsr Outcome
	; JMP L3
	bra L3
L26:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+260
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+260
	jsr Outcome
	; JMP L3
	bra L3
L25:
	; fcall	 R2 "Outcome" R3 R0 "STRINGTABLE"+256
	txy
	lda 3,s
	tax
	lda #STRINGTABLE+256
	jsr Outcome
	; JMP L3
	bra L3
__exit:
.)
	rts
	; Func Clobbered : f
.text
SoftStem:
	; 2 outgoing mem params
	; 4 incoming params, 1 of which are mem params
	; 1 local mem vars, 1 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; Outgoing memory params             reside at stack indexes 0..1 (bytes 0..3)
	; Incoming memory params             reside at stack indexes 3..3 (bytes 6..7)
	; Local variables reused from params reside at stack indexes 3..3 (bytes 6..7)


	phx
	phx
.(
__entry:
	; fcall	 R2 "SoftAndEssive" R0 0 0 R3 0
	lda 7,s
	sta 1,s
	tdc
	tay
	sta 3,s
	jsr SoftAndEssive
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : 7
.text
a:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; As a consequence, stack will have 0 local slots (true vars + outgoing mem params + align).
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; fcall	 R0 "IsFront" R0
	jsr IsFront
	tax
	; ifnz	 R0, JMP L43
	cpx #1 
	bcs L43
	; copy	 R2 R0
	txa
L44:
	; add	 R0 R2 "STRINGTABLE"+319
	clc
	adc #STRINGTABLE+319
	tax
L45:
	; read	 R2 R0
	lda !0,x
	and #$FF
L3:
	; ret	 R2
	bra __exit
L43:
	; copy	 R2 1
	lda #1
	; JMP L44
	bra L44
__exit:
.)
	rts
	; Func Clobbered : 7
.text
append:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; This is a leaf function, and it seems 0 red-zone will be enough
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; write	 R0 R1
	tya
	sep #$20
	sta !0,x
	rep #$20
	; add	 R2 R0 1
	inx
	txa
	; write	 R2 0
	tax
	sep #$20
	stz !0,x
	rep #$20
L3:
	; ret	 R2
	bra __exit
__exit:
.)
	rts
	; Func Clobbered : f
.text
find:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 1 local mem vars, 0 of which are reused params, leaving only 1 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; read	 R2 R1
	lda !0,y
	and #$FF
	; ifnz	 R2, JMP L0
	cmp #1 
	bcs L0
L5:
	; ret	 0
	tdc
	bra __exit
L0:
	; ifeq	 R0 R2, JMP L1
	sta 1,s
	txa
	cmp 1,s
	beq L1
	; add	 R1 R1 1
	iny
	; JMP find
	bra __entry
L1:
	; ret	 R1
	tya
	bra __exit
__exit:
.)
	plx

	rts
	; Func Clobbered : f
.text
stpcpy:
	; 0 outgoing mem params
	; 2 incoming params, 0 of which are mem params
	; 1 local mem vars, 0 of which are reused params, leaving only 1 true local vars
	; As a consequence, stack will have 1 local slots (true vars + outgoing mem params + align).
	; An offset of 2 items (4 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..0 (bytes 0..1)


	phx
.(
__entry:
	; read	 R2 R1
	lda !0,y
	and #$FF
	; ifnz	 R2, JMP L19
	cmp #1 
	bcs L19
L21:
	; write	 R0 0
	sep #$20
	stz !0,x
	rep #$20
L20:
	; ret	 R0
	txa
	bra __exit
L19:
	; add	 R3 R0 1
	pha
	inx
	txa
	dex
	sta 3,s
	pla
	; write	 R0 R2
	sep #$20
	sta !0,x
	rep #$20
	; copy	 R0 R3
	lda 1,s
	tax
	; add	 R1 R1 1
	iny
	; JMP stpcpy
	bra __entry
__exit:
.)
	plx

	rts
	; Func Clobbered : 1f
.text
stpcpyn:
	; 0 outgoing mem params
	; 3 incoming params, 0 of which are mem params
	; 2 local mem vars, 0 of which are reused params, leaving only 2 true local vars
	; As a consequence, stack will have 2 local slots (true vars + outgoing mem params + align).
	; An offset of 3 items (6 bytes) is used to access caller frame
	; True local variables               reside at stack indexes 0..1 (bytes 0..3)


	phx
	phx
.(
__entry:
	; fcall	 R3 "Length" R1
	phx
	tyx
	phx
	pha
	jsr Length
	sta 7,s
	pla
	ply
	plx
	; neg	 R2 R2
	eor #-1
	sec
	adc #0
	; add	 R2 R2 R3
	clc
	adc 1,s
L23:
	; ifnz	 R2, JMP L22
	cmp #1 
	bcs L22
L21:
	; write	 R0 0
	sep #$20
	stz !0,x
	rep #$20
L20:
	; ret	 R0
	txa
	bra __exit
L22:
	; add	 R3 R1 1
	pha
	iny
	tya
	dey
	sta 3,s
	pla
	; read	 R4 R1
	pha
	lda !0,y
	and #$FF
	sta 5,s
	pla
	; write	 R0 R4
	pha
	lda 5,s
	sep #$20
	sta !0,x
	rep #$20
	pla
	; copy	 R1 R3
	phx
	tsx
	ldy 3,x
	plx
	; add	 R0 R0 1
	inx
	; add	 R2 R2 -1
	clc
	adc #-1
	; JMP L23
	bra L23
__exit:
.)
	plx
	plx

	rts
	; Func Clobbered : 7
.text
strend:
	; 0 outgoing mem params
	; 1 incoming params, 0 of which are mem params
	; 0 local mem vars, 0 of which are reused params, leaving only 0 true local vars
	; This is a leaf function, and it seems 0 red-zone will be enough
	; An offset of 1 items (2 bytes) is used to access caller frame

.(
__entry:
	; read	 R1 R0
	lda !0,x
	and #$FF
	tay
	; ifnz	 R1, JMP L2
	cpy #1 
	bcs L2
L20:
	; ret	 R0
	txa
	bra __exit
L2:
	; add	 R0 R0 1
	inx
	; JMP strend
	bra __entry
__exit:
.)
	rts
